// server/src/rooms/DemoRoom.js

import colyseusPkg from "colyseus";
const { Room } = colyseusPkg;

import { EventStore } from "../db/EventStore.js";
import { randomUUID } from "node:crypto";
import { Schema, MapSchema } from "@colyseus/schema";
import * as schema from "@colyseus/schema"; // for defineTypes

// CHANGED: import verifyJWT in addition to assertMember
import { verifyJWT, assertMember } from "../auth/jwt.js";

class PlayerState extends Schema {}
schema.defineTypes(PlayerState, {
  id: "string",
  name: "string",
  hp: "int16",
  xp: "int32",
  role: "string",
});

class DemoState extends Schema {
  constructor() {
    super();
    this.players = new MapSchema();
    this.version = 0;
  }
}
schema.defineTypes(DemoState, {
  players: { map: PlayerState },
  version: "int32",
});

const SNAPSHOT_EVERY = 50;

// Pure applier for schema state (must mirror EventStore's JSON events)
function applyEvent(state, evt) {
  switch (evt.type) {
    case "PLAYER_UPSERT": {
      const { id, name, role } = evt.payload;
      let p = state.players.get(id);
      if (!p) {
        p = new PlayerState();
        p.id = id;
        p.name = name ?? "Player";
        p.role = role ?? "player";
        p.hp = 10;
        p.xp = 0;
        state.players.set(id, p);
      } else {
        if (name !== undefined) p.name = name;
        if (role !== undefined) p.role = role;
      }
      break;
    }
    case "NAME_SET": {
      const { id, name } = evt.payload;
      const p = state.players.get(id);
      if (p) p.name = String(name ?? "").slice(0, 64);
      break;
    }
    case "HP_SET": {
      const { id, hp } = evt.payload;
      const p = state.players.get(id);
      if (p) p.hp = Math.max(-32768, Math.min(32767, Number(hp || 0)));
      break;
    }
    case "XP_ADD": {
      const { id, amount } = evt.payload;
      const p = state.players.get(id);
      if (p) p.xp = Math.max(-2147483648, Math.min(2147483647, p.xp + Number(amount || 0)));
      break;
    }
    default:
      // ignore unknowns
      break;
  }
  state.version += 1;
}

export class DemoRoom extends Room {
  // ADDED: onAuth to populate client.user (prevents undefined campaignId)
  async onAuth(client, options) {
    const token = String(options?.token || "");
    const payload = await verifyJWT(token); // { sub, email, name, role, campaignId? }

    client.user = {
      id: payload.sub,
      email: payload.email,
      name: payload.name ?? options?.name ?? "Player",
      role: payload.role ?? "player",
      campaignId: payload.campaignId ?? options?.campaignId ?? null,
    };

    if (!client.user.campaignId) {
      throw new Error("missing campaignId in token/options");
    }
    return true;
  }

  async onCreate(options) {
    this.campaignId = options?.campaignId;
    this.streamId = this.campaignId; // UUID expected by DB

    // empty schema state first
    this.setState(new DemoState());

    // bind event store
    this.eventStore = new EventStore(this.streamId, "demo");

    // rehydrate from snapshots + events (await to ensure ready before ops)
    const { version, state } = await this.eventStore.load();

    // hydrate players map into schema
    this.state.players.clear();
    const players = state?.players || {};
    for (const [id, v] of Object.entries(players)) {
      const p = new PlayerState();
      p.id = v.id;
      p.name = v.name ?? "Player";
      p.role = v.role ?? "player";
      p.hp = Number.isFinite(v.hp) ? v.hp : 10;
      p.xp = Number.isFinite(v.xp) ? v.xp : 0;
      this.state.players.set(id, p);
    }
    this.state.version = version;

    // message handlers
    this.onMessage("op", async (client, data) => {
      await this.handleOp(client, data);
    });
    this.onMessage("chat", async (client, data) => {
      await this.handleChat(client, data);
    });
  }

  // CHANGED: null-safe & clearer errors
  assertSameCampaign(client) {
    if (!this.campaignId) {
      throw new Error("room missing campaignId");
    }
    const cid = client?.user?.campaignId ?? null;
    if (cid !== this.campaignId) {
      throw new Error("cross-campaign access denied");
    }
  }

  requireRole(client, roles) {
    if (!roles.includes(client.user.role)) {
      throw new Error("insufficient role");
    }
  }

  getOrInitPlayer(uid, userLike) {
    let ps = this.state.players.get(uid);
    if (!ps) {
      ps = new PlayerState();
      ps.id = uid;
      ps.hp = 10;
      ps.xp = 0;
      ps.name = userLike?.name || "Player";
      ps.role = userLike?.role || "player";
      this.state.players.set(uid, ps);
    } else {
      if (!ps.name) ps.name = userLike?.name || "Player";
      if (!ps.role) ps.role = userLike?.role || "player";
    }
    return ps;
  }

  async onJoin(client) {
    this.assertSameCampaign(client);
    await assertMember(this.campaignId, client.user.id);

    // upsert presence via event for persistence
    await this._commit(
      { type: "PLAYER_UPSERT", payload: { id: client.user.id, name: client.user.name, role: client.user.role } },
      { actor: client.user.id }
    );
  }

  async handleOp(client, data) {
    this.assertSameCampaign(client);
    await assertMember(this.campaignId, client.user.id);

    const type = data?.type;

    switch (type) {
      case "SET_NAME": {
        const id = client.user.id; // players can only name themselves
        const name = String(data?.name ?? "").slice(0, 64);
        await this._commit(
          { type: "NAME_SET", payload: { id, name } },
          { actor: client.user.id }
        );
        break;
      }

      case "SET_HP": {
        const targetId = String(data?.playerId ?? client.user.id);
        if (client.user.role === "player" && targetId !== client.user.id) {
          throw new Error("players may only adjust self");
        }
        if (client.user.role !== "player") {
          this.requireRole(client, ["owner", "dm"]);
        }
        const ps = this.getOrInitPlayer(targetId, targetId === client.user.id ? client.user : null);
        const hp = Number(data?.value ?? ps.hp);
        await this._commit(
          { type: "HP_SET", payload: { id: targetId, hp } },
          { actor: client.user.id }
        );
        break;
      }

      case "HP_ADD": {
        const targetId = String(data?.id ?? client.user.id);
        if (client.user.role === "player" && targetId !== client.user.id) {
          throw new Error("players may only adjust self");
        }
        const ps = this.getOrInitPlayer(targetId, targetId === client.user.id ? client.user : null);
        const amount = Number(data?.amount ?? 0);
        const hp = ps.hp + amount;
        await this._commit(
          { type: "HP_SET", payload: { id: targetId, hp } },
          { actor: client.user.id }
        );
        break;
      }

      case "ADD_XP":
      case "XP_ADD": {
        const targetId = String(data?.playerId ?? data?.id ?? client.user.id);
        if (client.user.role === "player" && targetId !== client.user.id) {
          throw new Error("players may only add XP to self");
        }
        const amount = Number(data?.amount ?? 0);
        if (!Number.isFinite(amount) || Math.abs(amount) > 1_000_000) {
          throw new Error("invalid xp amount");
        }
        await this._commit(
          { type: "XP_ADD", payload: { id: targetId, amount } },
          { actor: client.user.id }
        );
        break;
      }

      default:
        // ignore unknown ops
        break;
    }
  }

  async handleChat(client, payload) {
    this.assertSameCampaign(client);
    await assertMember(this.campaignId, client.user.id);

    const ps = this.getOrInitPlayer(client.user.id, client.user);
    const msg = String(payload?.text ?? "").slice(0, 500);
    this.broadcast("chat", { from: ps.name, text: msg });
  }

  // --- persistence plumbing ---

  async _commit(evt, meta = {}) {
    // 1) append to store
    const version = await this.eventStore.append(evt.type, evt.payload, {
      correlationId: meta.correlationId || randomUUID(),
    });

    // 2) apply to in-memory schema
    applyEvent(this.state, evt);

    // 3) snapshot periodically
    if (version % SNAPSHOT_EVERY === 0) {
      const plain = {
        version: this.state.version,
        players: Object.fromEntries(
          Array.from(this.state.players).map(([k, v]) => [
            k,
            { id: v.id, name: v.name, hp: v.hp, xp: v.xp, role: v.role },
          ])
        ),
      };
      await this.eventStore.saveSnapshot(version, plain);
    }
  }
}
